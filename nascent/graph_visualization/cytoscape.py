# -*- coding: utf-8 -*-
##    Copyright 2015 Rasmus Scholer Sorensen, rasmusscholer@gmail.com
##
##    This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# pylint: disable=C0103

"""

Module for interacting with Cytoscape.


"""

from pandas.core.frame import DataFrame
import logging
logger = logging.getLogger(__name__)

#import requests
#import py2cytoscape
from py2cytoscape.data import cyrest_client

# Local/relative imports
from .live_visualizer_base import LiveVisualizerBase

cytoscape_layouts = ['attribute-circle', 'stacked-node-layout', 'degree-circle',
                     'circular', 'attributes-layout', 'kamada-kawai',
                     'force-directed', 'grid', 'hierarchical',
                     'fruchterman-rheingold', 'isom']
LAYOUT_MAP = {'force': 'force-directed'}

def edge_suid_to_names_mapper(frame, directed=False):
    """ Given a data frame, return {suid: (node-source, node-target)} map dict. """
    if directed:
        return {suid: (source, target)
                for suid, source, target in zip(frame.index, frame['source'], frame['target'])}
    else:
        return {suid: frozenset((source, target))
                for suid, source, target in zip(frame.index, frame['source'], frame['target'])}

def edge_names_to_suid_mapper(frame):
    """ Given a data frame, return {(node-source, node-target): suid} map dict. """
    return {v: k for k, v in edge_suid_to_names_mapper(frame).items()}


class CytoscapeStreamer(LiveVisualizerBase):
    """
    Draw graph live using Cytoscape with cyREST plugin.
    REST API documentation: http://idekerlab.github.io/cyREST/
    """

    def __init__(self, config):
        super().__init__(config)
        host = config.get('visualization_host', '127.0.0.1')
        port = config.get('visualization_port', 1234)
        self.client = cyrest_client.CyRestClient(ip=host, port=port)
        self.network = None     # CyNetwork object for interacting with the Cytoscape graph (network)
        #self.name_to_suid = {} # edit: for now, we store nodes and edges separately. They could probably be joined.
        # While we are debugging, keep track of deletions:
        self.id_key = 'SUID'


    def initialize_graph(self, graph, reset=True):
        """ Initialize the visualization based on a networkx graph. """
        if reset:
            self.client.session.delete()
        name = self.config.get('vizualisation_network_name')
        coll = self.config.get('vizualisation_network_collection')
        if graph is None:
            # create args:
            # suid: network id, name: graph name, collection: (?)
            # data (a dict with form {'data': {...}, 'elements': {'nodes': [...], 'edges': [...]}} )
            self.network = self.client.network.create(name=name, collection=coll)
        else:
            # Create create from networkx graph.
            # Note: client.network represents the "network transport/communication" logic of the client,
            # but it returns a 'CyNetwork' which can be used as a proxy for the cytoscape network (*graph*).

            #self.network = self.client.network.create_from_networkx(graph, collection='Generated by NetworkX')

            # Hmm, this is weird: when creating from networkx,
            # util.util_networkx.from_networkx => cygraph --> data.network_client.NetworkClient.create
            # then one such edge, e.g. http://localhost:1234/v1/networks/734/edges/772, will contain:
            # {"data":{"source":758,"target":759,"SUID":772,"selected":false,"len":2.0,
            #          "source":"B","target":"C","weight":2.0}}
            # NOTE that there is two "source" and two "target" entries!
            # When we create a network by POSTing a graph network as raw JSON data structure to
            #   http://localhost:1234/v1/networks/?collection=<network collection str>
            # then we actually get this data structure! (check http://localhost:1234/v1/networks.json)
            # This means that in order to use create_from_networkx, we need to know the SUIDs in advance
            # and use these as the networkx node names. That seems... unreasonable.
            # However,
            # In the cyREST repository under examples/python/basic/CytoscapeREST_Basic1-checkpoint.ipynb
            # it is shown how to use the resource at host/v1/networks.
            # Indeed,
            # See the createNetwork and addNetwork methods in the cyREST source code in
            #   src/main/java/org/cytoscape/rest/internal/resource/NetworkResource.java
            # as well as the two methods
            #   edgeListReaderFactory.createTaskIterator and cytoscapeJsReaderFactory.createTaskIterator
            #
            # SOLUTION:
            # For now, I'll just create the graph from networkx using .add_nodes and .add_edges methods.
            # This uses three POST requests to the server instead of one, but only one time.

            self.network = self.client.network.create(name=name, collection=coll)

            node_names = list(graph.nodes())
            edges = list(graph.edges())
            #print("node_names:", node_names)
            #print("edges:", edges)
            self.add_nodes(node_names)
            self.add_edges(edges, directed=False)
            # Register the current nodes:
            # edit: this is done by add_nodes/add_edges
            #self.register_new_nodes(self.network.get_node_table(format='cytoscapejs')) # default format is'dataframe'
            #self.register_new_edges(self.network.get_edge_table(format='cytoscapejs'))

        return self.network


    def apply_layout(self, layout, params=None):
        self.client.layout.apply(layout, network=self.network)


    def add_node(self, node_name, attributes=None):
        """ Add a single node. """
        return self.add_nodes([node_name], attributes=attributes)


    def add_nodes(self, node_name_list, attributes=None):
        """ Add multiple nodes. """
        new_node_ids = self.network.add_nodes(node_name_list, format='json')
        # when POSTing new edges to the cyREST v1/networks/5306/nodes resource, it
        # returns a json-formatted list of dicts with 'SUID', 'source', target' keys.
        # I've made a change to py2cytoscape CyNetwork class to allow add_methods to
        # return json or a {SUID: name} dict.
        print("new_node_ids:", new_node_ids)
        self.register_new_nodes(new_node_ids)
        return new_node_ids


    def delete_node(self, node_name):
        """ Delete a single node from the graph. """
        node_id = self.node_name_to_suid.pop(node_name)
        try:
            self.network.delete_node(node_id)
        except Exception as e:
            print("Error deleting node %s: %s" % (node_id, e))
            # Re-insert node_name => node_id entry
            self.node_name_to_suid[node_name] = node_id
        else:
            test_name = self.node_suid_to_name.pop(node_id)
            if test_name != node_name:
                print("WARNING: Mapping issue: node_suid_to_name[node_id] != node_name")


    def delete_nodes(self, node_names_list):
        for node_name in node_names_list:
            self.delete_node(node_name)


    def add_edge(self, source, target, directed=True, interaction=None, bidirectional=None, attributes=None):
        """
        :param source:
        :param target:
        :param interaction:
        :param directed:
        :param bidirectional: If True, and directed is also True, add two directed edges,
                              one from source to target and another from target to source.
        """
        # For Cytoscape, we need to convert
        edges = [{'source': self.node_name_to_suid[source],
                  'target': self.node_name_to_suid[target],
                  'interaction': interaction or 'h',
                  'directed': directed}]
        if directed and bidirectional:
            edges += [{'source': self.node_name_to_suid[target],
                       'target': self.node_name_to_suid[source],
                       'interaction': interaction,
                       'directed': directed}]
        new_edge_ids = self.network.add_edges(edges, format='json')
        self.register_new_edges(new_edge_ids, directed=directed)
        return new_edge_ids


    def add_edges(self, edges, directed, attributes=None):
        """
        Perform some translation from nascent directive to py2cytoscape directive.
        edges must be a list of dicts as:
            [{'source': <name>, 'target': <name>, 'interaction': <str>, 'directed': <bool>}, ...]
        This method will take care of mapping names->SUIDs before submitting it
        (this happens in-place, so you may want to make a copy of edges if you need it for anything important)
        """
        # For Cytoscape, we must give SUIDs to add_edges, so start by translating name->suid:
        edges = [self.translate_edge(edge) for edge in edges]
        ## TODO: Inject attributes?
        new_edge_ids = self.network.add_edges(edges, format='json')
        # when POSTing new edges to the cyREST v1/networks/5306/edges resource, it
        # returns a json-formatted list of dicts with 'SUID', 'source', target' keys.
        self.register_new_edges(new_edge_ids, directed=directed)  # Consider being able to add directed here!
        return new_edge_ids


    def translate_edge(self, edge):
        """ Translates node names in edge to SUIDs. """
        if isinstance(edge, dict):
            edge['source'] = self.node_name_to_suid[edge['source']]
            edge['target'] = self.node_name_to_suid[edge['target']]
        else:
            # edge might be a list or tuple with (source, target, directed, ...)
            edge = list(edge) # ensure mutable list and not tuple
            for i in range(2):
                edge[i] = self.node_name_to_suid[edge[i]]
        return edge


    def delete_edge(self, source, target, directed=True):
        """
        Delete a single edge from the graph.
        :param source:, :param target: the source and target which edge is connecting.
        """
        # For cytoscape, we need to convert node names to suid
        # before using the suid (source, target) to get the edge's suid:
        # edit: when we use a nx graph to initialize a graph and then use
        # node_suid_to_name[<suid>] = (source-name, target-name) node_name_to_suid
        source, target = self.node_name_to_suid[source], self.node_name_to_suid[target]
        if directed:
            key, fallback = ((source, target), frozenset((source, target)))
        else:
            fallback, key = ((source, target), frozenset((source, target)))
        try:
            edge_id = self.edge_names_to_suid.pop(key)
        except KeyError:
            print("Unable to find expected edge key %s in node_name_to_suid map." % (key,))
            try:
                edge_id = self.edge_names_to_suid.pop(fallback)
                key = fallback
            except KeyError:
                print("- Also unable to find fallback key %s in node_name_to_suid map." % (fallback,))
                return
        try:
            self.network.delete_edge(edge_id)
        except Exception as e:
            print("Error deleting node %s: %s" % (edge_id, e))
            # Re-insert node_name => node_id entry
            self.edge_names_to_suid[key] = edge_id
            return False
        else:
            test_name = self.edge_suid_to_names.pop(edge_id)
            self.deleted_name_to_suid.append({key: edge_id})
            self.deleted_suid_to_name.append({edge_id: key})
            if test_name != key:
                print("WARNING: Mapping issue: node_suid_to_name[node_id] != node_name")
            return True


    def delete_edges(self, edges):
        """ Delete all edges in :param edges:. """
        all_ok = 1
        for edge in edges:
            try:
                source, target = edge['source'], edge['target']
            except KeyError:
                source, target = edge['nodes']
            directed = edge['directed']
            all_ok *= self.delete_edge(source, target, directed)
        return bool(all_ok)



    #def edge_names_key(self, source, target, directed=True):
    #    if directed:
    #        return (source, target)
    #    else:
    #        return frozenset((source, target))
